!! this module includes all associated parameters to generate the forcing field 
!! generated by the nonlinear interaction between the incident and the reflecting internal wave 
!! field 

subroutine getGroupVelocity(Cgx,Cgy,N,omega,kx,kz)
		
	!BV frequency and the internal wave frequency
	real*8, intent(in):: N,omega	
 	! the wave numbers and the group velocities
	real*8, intent(inout):: kx,kz,Cgx,Cgy

	! let's first calculate the wave number in z direction
	call getWaveNumberInZ(N,omega, kx, kz)
	
	! the group velocity in x direction
	Cgx=N/dsqrt(kx**2.+kz**2.)-N*(kx**2.)/dsqrt((kx**2.+kz**2.)**3.)

	! the group velocity in z direction
	Cgy=N*(kx*kz)/dsqrt((kx**2.+kz**2.)**3.)
	
	
end subroutine getGroupVelocity

subroutine getWaveNumberInZ(N,omega, kx, kz)
		
	!BV frequency and the internal wave frequency
	real*8, intent(in):: N,omega,kx	
 	! the wave numbers
	real*8, intent(inout)::  kz

	kz=dsqrt((N*kx/omega)**2.-kx**2.)
	
end subroutine getWaveNumberInZ

subroutine getReflectionPoint(x_reflect,x_ref,Cgx,Cgz,Lx,Lz)
		
	!the reference point and the reflection point
	real*8, intent(inout),dimension(2):: x_ref,x_reflect	
 	! the group velocities and the domain dimensions
	real*8, intent(inout):: Cgx,Cgz,Lx,Lz
 	! the propagation angle 
	real*8 theta
	
	! let's calculate propagation angle
	theta=datan(Cgx/Cgz)
	
	! it has to be the top level in z direction
	x_reflect(2)=Lz
	! the x coordinate of the reflection points
	x_reflect(1)=x_ref(1)+(Lz-x_ref(2))*dtan(theta)
	
	
end subroutine getReflectionPoint

subroutine getIncidentAmplitude(Amp,x,x_ref,sigma, alpha, A_0, kx, kz)
		
	!the original coordinates and the reference coordinate
	real*8, intent(in),dimension(2):: x,x_ref	
	! the amplitude
	real*8, intent(inout):: Amp	
 	! the  half width, the viscous dissipation cofficient and the initial amplitude and wave numbers
	real*8, intent(in):: sigma, alpha, A_0, kx, kz
	!the rotated coordinates
	real*8, allocatable:: x_rot(:)	
	!the rotation angle
	real*8 theta	
	! it is two dimensional rotation
	allocate(x_rot(2))

	! the rotation angle
	theta=datan(-1.d0*kx/kz)
	! print*,"the angle of rotation", theta
	! let's get the rotated coordinates
	call Rotate2D(x_rot,x,x_ref,theta)
	
	!the amplitude calculation 
	Amp=A_0*dexp(-1.*alpha*x_rot(1))*dexp(-0.5*(x_rot(2)/sigma)**2.)
	
end subroutine getIncidentAmplitude

subroutine Rotate2D(x_rot,x,x_ref,theta)
		
	!the original coordinates and the reference coordinate
	real*8, intent(in),dimension(2):: x,x_ref
	!the rotated coordinates
	real*8, intent(inout),dimension(2):: x_rot
	!the rotation angle
	real*8, intent(in):: theta
	
	! let's perform the rotation 
	x_rot(1)=dcos(theta)*(x(1)-x_ref(1))-dsin(theta)*(x(2)-x_ref(2))
	x_rot(2)=dsin(theta)*(x(1)-x_ref(1))+dcos(theta)*(x(2)-x_ref(2))
	
end subroutine Rotate2D

subroutine BackRotate2D(x_rot,x,x_ref,theta)
		
	!the original coordinates and the reference coordinate
	real*8, intent(in),dimension(2):: x,x_ref
	!the rotated coordinates
	real*8, intent(inout),dimension(2):: x_rot
	!the rotation angle
	real*8, intent(in):: theta
	
	! let's perform the rotation 
	x_rot(1)=dcos(theta)*x(1)-dsin(theta)*x(2)+x_ref(1)
	x_rot(2)=dsin(theta)*x(1)+dcos(theta)*x(2)+x_ref(2)
	
end subroutine BackRotate2D